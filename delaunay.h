/**
 * @file Contains all the implementation of the delaunay data structure.
 */
#ifndef DELAUNAY_H_
#define DELAUNAY_H_

#include "basic_geo.h"
#include <string>

namespace mesh_generation {

/**
 * Defines the data type used to store the information of a single triangle in
 * the delaunay triangulation data structure.
 */
struct DelaunayTriangle {
  DelaunayTriangle();
  DelaunayTriangle(std::vector<int> point_ids,
                   std::vector<int> triangle_neighbor_ids);
  /**
   * Holds a triplet of point ids describing the triangle, sorted in clockwise
   * order.
   */
  std::vector<int> point_ids;

  /**
   * Holds a triplet of triangle ids describing the neighboring triangles.
   */
  std::vector<int> triangle_neighbor_ids;

  /**
   * Holds the list of triangle ids of its children (generated by splitting the
   * triangle.
   */
  std::vector<int> triangle_child_ids;
};

/**
 * Implements the delaunay triangulation algorithm described at:
 *
 * Computational Geometry: Algorithms and Applications Third Edition (March
 * 2008) Chapter 9
 *
 * As this is a offline algorithm, this implementation assumes that the points
 * are given between the rectangle [0:W,0:H]. For this particular case the
 * maximum lexicografical coordinate is always going to be p0 = (W,H), and is
 * allays assumed to be part of the set of points P (which allows the algorithm
 * to behave online).
 *
 * Note that this can be easily modified to work in offline mode, by just
 * calculating P0 on the whole set of input points.
 */
class DelaunayMesh {
public :
  /**
   * Creates a delaunay mesh that will have the given point as the
   * lexicographically bigger point among all the ones that will be latter
   * inserted.
   */
  DelaunayMesh(Point lexicographically_bigger,
                list< vector<Point> > simplified_curves);

  /**
   * Inserts the given point to the delaunay triangulation.
   *
   * @param point The point to be inserted, note that this point must be unique
   *          among the set of already inserted points.
   */
  void InsertPoint(Point pt);

  /**
   * Checks if the current triangulation satisfies the delaunay properties.
   * Note that this process is very expensive since it takes O(N^2) operations,
   * where N is the number of points.
   */
  bool IsValidDelaunay() const;

  /**
   * Plots the set of points already inserted. The function writes into a file
   * the commands required to plot the points using gnuplot. The files used are:
   * points_set, containing the description of the points and graph.conf,
   * containing the plotting commands.
   */
  void PlotPoints() const;

  /**
   * Plots the set of points already inserted. The function writes into a file
   * the commands required to plot the points using gnuplot. The files used are:
   * points_set, containing the description of the points and graph.conf,
   * containing the plotting commands.
   *
   * @param wrong circles Defines whether the plot should check the triangles
   *        and display the ones that don't satisfy the delaunay property, this
   *        procedure takes O(N^2) operations, where N is the number of points.
   * @param rand_circles Plots random circumcircles, plotting around 4% of the
   *        total number of circumcircles.
   */
  void PlotTriangulation(bool wrong_circles, bool rand_circles) const;

  /**
   * @return The total number of triangles in the triangle tree.
   */
  int TriangleTreeSize() const;

  /**
   * @return The number of points inserted in the triangulation.
   */
  int PointSetSize() const;

  /**
   * @return The number of triangles visited on every insertion operation.
   */
  double AverageInsertionCost() const;

private:
  /**
   * Checks whether the given point is inside or in the edge of the triangle
   * defined by _triangles[triangle_id].
   * A point is considered inside a triangle if it is to the right of all the
   * triangle's edges when visiting them in clockwise order.
   */
  bool IsInsideTriangle(int triangle_id, const Point& point) const;

  /**
   * Checks whether the given points belongs to an edge of the triangle with id
   * triangle_id.
   * The parameter edge_start_pos returns the position of the start point in
   * the array of point_ids of the edge to which point belongs.
   */
  bool BelongsTriangleBorder(const Point& point, int triangle_id,
                             int* edge_start_pos) const;
  /**
   * Finds the triangle which encloses the given point.
   * @return The triangle id (a leaf in the triangle DAG). If it belongs to an
   * edge, returns any of the neighboring triangles.
   */
  int FindEnclosingTriangle(const Point& point);// const;

  /**
   * Creates a new triangle, without data.
   * @return The triangle_id of the new created triangle.
   */
  int StoreTriangle(const DelaunayTriangle& triangle);

  /**
   * Stores the given point.
   * @return The point id.
   */
  int StorePoint(const Point& point);

  /**
   * @return the triangle id of the new allocated triangle.
   */
  int AllocateNewTriangle();

  /**
   * @return the point id of the new allocated point.
   */
  int AllocateNewPoint();

  /**
   * @return the reference of the triangle stored with the given id.
   */
  DelaunayTriangle& GetTriangleRef(int triangle_id);

  /**
   * @return the value of the triangle stored with the given id.
   */
  const DelaunayTriangle& GetTriangleVal(int triangle_id) const;
  /**
   * @return the point stored with the given id.
   */
  Point GetPoint(int point_id) const;

  /**
   * @return whether the current point id belongs to a infinite point.
   */
  bool IsInfinitePoint(int point_id) const;

  /**
   * Checks if the circumcircle of the given triangle does not contain a point
   * inside its region, it performs a linear check in the set of points.
   */
  bool IsValidTriangle(const DelaunayTriangle& triangle) const;

  /**
   * Updates the neighbor of the given triangle. This is called when a neighbor
   * triangle is replaced by a new inserted one.
   * @param triangle_id Triangle that is going to be updated.
   * @param old_neighbor The triangle id of the old neighbor.
   * @param new_neighbor The triangle id of the new neighbor.
   */
  void UpdateNeighbor(int triangle_id, int old_neighbor, int new_neighbor);

  /**
   * Checks if the given triangle satisfies the Delaunay property at the given
   * edge. For the edge to be legal, the circumcircle of its adjacent triangles
   * should be empty. In case it is not legal, flips the edge and legalizes it.
   *
   * @param triangle_id Refers to the triangle to be checked.
   * @param side_index The triangle's side to be checked.
   */
  void LegalizeSide(int triangle_id, int side_index);

  /**
   * Adds a point to the border of a triangle defined by the triangle_id.
   *
   * @param triangle_id The id of the triangle to be modified.
   * @param point_id The id of the point to be inserted.
   * @param side_index The side in the triangle to be modified.
   */
  void InsertBorderPoint(int triangle_id, int point_id, int side_index);

  /**
   * Inserts a point inside an already existing triangle.
   *
   * @param triangle_id The id of the triangle in which the point lies.
   * @param point_id The id of the point to be inserted.
   */
  void InsertInnerPoint(int triangle_id, int point_id);
  /**
   * Finds the index in which the given neighbor_id occurs in the list of
   * neighbors of the given triangle_id
   * @param triangle_id Triangle id where the neighbor is searched.
   * @param neighbor_id Neighbor's triangle id to be found.
   */
  int NeighborSide(int triangle_id, int neighbor_id) const;

  /**
   * Writes the set of points to a file with the given name, the points are
   * write each in a separate line, with the x and y coordinated separated with
   * a tab (gnuplot format). Return the bounding box of the saved points.
   */
  void SavePointsToFile(const std::string& file_name, double* min_x,
                        double* max_x, double* min_y, double* max_y) const;
  /**
   * Set of points associated with their point ids.
   */
  std::map<Point, int> _point_to_id;

  /**
   * Set of inserted points.
   */
  std::vector<Point> _points;

  /**
   * Set of border edges, pair(point_id, point_id).
   */
  std::unordered_set< pair<int, int> > border_edges;

  /**
   * Each position contains .
   */
  std::vector<DelaunayTriangle> _triangles;

  /**
   * Number of triangles visited through all the queries.
   */
  int _total_query_operations;
};
}  // namespace mesh_generation
#endif
